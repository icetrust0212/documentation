---
sidebar_position: 5
description: Verida Developer Tutorial 
image: https://uploads-ssl.webflow.com/60e8365cd5794f8db04151ed/6107868980521e0acf27b2d9_favicon.svg
keywords: [Verida, Web3, Developers, Tutorial]
---



# Tutorial

## Introduction

This demonstration authenticates a user with the Verida Vault to unlock an [`application context`](/concepts/application-contexts.md)
 of encrypted data and messaging.

The following links may also be helpful: 
* [Verida Single Sign On (SSO) documentation](/single-sign-on-sdk/single-sign-on-sdk.md)
* [Glossary (Common Terms)](glossary.md)

## Getting Help

* [Discord Chat](https://discord.com/invite/qb6vS43)


## Login

The code below shows how to login to the Verida network. It is live - you can press the "Login" button to login, and edit the code to see how it works. 


<!--
Implementation Notes

Because of the way Docusaurus and MDX live code is implemented, it is tricky passing state between live code elements.
Each is a separate React component, and we can't modify parent components to share state, or to be a React Context.Provider.

Instead we use a React state-pool. See https://dev.to/yezyilomo/you-can-definitely-use-global-variables-to-manage-global-state-in-react-17l3
-->
```jsx live
VeridaLoginExample = () => {

    // We use a React state-pool to manage global state and pass between live code blocks
    const [DID, setDID] = useGlobalState("globalDID");
    const [veridaContext, setVeridaContext] = useGlobalState("globalVeridaContext")

    this.CONTEXT_NAME = 'Verida: Tutorial'
    this.VERIDA_TESTNET_DEFAULT_SERVER = 'https://db.testnet.verida.io:5002/'

    login = async function() {


        const account = new VaultAccount({
            defaultDatabaseServer: {
                type: 'VeridaDatabase',
                endpointUri: this.VERIDA_TESTNET_DEFAULT_SERVER
            },
            defaultMessageServer: {
                type: 'VeridaMessage',
                endpointUri: this.VERIDA_TESTNET_DEFAULT_SERVER
            },
        })

        const context = await Network.connect({
            client: {
                environment: 'testnet'
            },
            account: account,
            context: {
                name: this.CONTEXT_NAME
            }
        })
        setVeridaContext(context)

        const did = await account.did()
        setDID(did)

    }


    logout = () => {
        veridaContext.
            getAccount().
            disconnect(
                    this.CONTEXT_NAME
                ).then(() => {
                    setDID(null)
                    setVeridaContext(null)
                }
        );
    }

    this.login = this.login.bind(this);  
    this.logout = this.logout.bind(this);

    const isLoggedIn = (DID !== null);

    if (isLoggedIn) {
        // user is logged in
        return (
            <div>
                <h3>Logged in as DID: {DID}</h3>
                <button onClick={this.logout}>Logout</button>
            </div>
        );
    } else {
        return (
            <div>
                <button onClick={this.login}>Login</button>
            </div>
        );
    }

}

```

## Messaging

Every application has a built-in inbox for receiving messages and outbox for sending messages. This allows users and applications to send data between each other knowing nothing than the other user's DID and application name.

This example sends a contact record to a user's Verida Vault mobile application. 


```jsx live
VeridaMessagingExample = () => {
    const [DID, setDID] = useGlobalState("globalDID");
    const [veridaContext, setVeridaContext] = useGlobalState("globalVeridaContext")

    const [status, setStatus] = useState(null)

    sendMessage = async function() {
        setStatus(null)



        // The data message we are sending
        const data = {
            data: [
                {
                name: 'Verida Example',  // try editing these values and resend the message
                firstName: 'Verida',
                lastName: 'Example',
                email: 'verida.example@example.com',
                schema: 'https://common.schemas.verida.io/social/contact/v0.1.0/schema.json'
                }
            ]
        }

        const subject = 'New contact details for ' + data.data[0].name;
        // we need to set it to the correct message type
        const messageType = 'inbox/type/dataSend'

        const config = {
            recipientContextName: 'Verida: Vault'
        }

        const messaging = await veridaContext.getMessaging()

        // Now send the message
        // DID is set to whatever DID you logged in with
        await messaging.send(DID, messageType, data, subject, config)

        setStatus("Message Sent. Please check the inbox in the Verida Vault")
    }

    let statusMessage = <div></div>
    if (status !== null) {
        statusMessage = <div className="admonition admonition-info alert alert--info">{status}</div>
    }
        

    const isLoggedIn = (DID !== null);
    if (isLoggedIn) {
        return (
            <div>
                <div>
                    <button onClick={this.sendMessage}>Send Message</button>
                </div>
                
                {statusMessage}
            </div>
        )

    } else {
        return (
            <div className="admonition admonition-danger alert alert--danger">
                <h1>Please login <a href="#login">above</a></h1>
            </div>
        );
    }


}
```

## Databases

This example shows opening a database (in the `useEffect` function), saving data (the `addItem` function) and finally how to delete all data (the `deleteAll` function).

```jsx live
VeridaDatabaseExample = () => {
    const [DID, setDID] = useGlobalState("globalDID");
    const [veridaContext, setVeridaContext] = useGlobalState("globalVeridaContext")
    
    // tableRows the the records shown from the database
    const [tableRows, setTableRows] = useState([])

    generateTableRows = (items) => {
        // We render all available fields here
        // the "myvalue" column is the one we set in the addItem function below

        rows = items.map((item) => (
            <tr key={item._id}>
                <td>{item._id}</td>
                <td>{item.myvalue}</td> 
                <td>{item.insertedAt}</td>
                <td>{item.modifiedAt}</td>
                <td>{item._rev}</td>
            </tr>
        ))
        setTableRows(rows)
    } 

    addItem = async function() {
        // save a record with key "hello", value "world"
        //
        // Try editing the value saved here
        const item = await Window.db.save({
            myvalue: 'hello world' // change this, and press the "Add Item" button
        });

        // retrieve the items
        const items = await Window.db.getMany()
        generateTableRows(items)
    }
    
    deleteAll = async function() {
        // delete all items from this database
        await Window.db.deleteAll()
        generateTableRows([])
    }

    useEffect( () => {
        // veridaContext will be null if the user isn't logged in
        if (veridaContext !== null) {
            // Open / create a test database
            veridaContext.openDatabase('test_db').then((database) => {
                Window.db = database

                database.getMany().then((items) => {
                    generateTableRows(items)
                });
            });   
        }
    }, [veridaContext]);


    const isLoggedIn = (DID !== null);
    
    if (isLoggedIn) {
        // user is logged in
        return (
            <div>
                <h3>Logged in as DID: {DID}</h3>
                <h4>Current data in database</h4>
                <table>
                    <thead>
                        <tr>
                            <td>_id</td>  
                            <td>myvalue</td>  
                            <td>insertedAt</td>  
                            <td>modifiedAt</td>  
                            <td>_rev</td>  
                        </tr>
                    </thead>
                    <tbody>
                        {tableRows}
                    </tbody>
                </table>

                <h4>Actions</h4>
                <button onClick={this.addItem}>Add Item</button>
                <br />
                <button onClick={this.deleteAll}>Delete All Items</button>
            </div>
        );
    } else {
        return (
            <div className="admonition admonition-danger alert alert--danger">
                <h1>Please login <a href="#login">above</a></h1>
            </div>
        );
    }
}

```

## Encryption 

Data in Verida is encrypted when it is sent to remote servers. We can inspect the local and remote database and see the unencrypted local data and the remote encrypted payload. 

```jsx live
VeridaEncryptionExample = () => {
    const [DID, setDID] = useGlobalState("globalDID");
    const [veridaContext, setVeridaContext] = useGlobalState("globalVeridaContext")


    const [localData, setLocalData] = useState("")
    const [remoteData, setRemoteData] = useState("")


    showLocal = async function() {
        const items = await Window.db.getMany() // get the database items
        const last_item = items.slice(-1)[0] // find the last item in the list
        

        data = await Window.db._localDb.get(last_item._id) // get the record
        console.log("Local data", data);

        setLocalData(data)
    }

    showRemote = async function() {
        const items = await Window.db.getMany() // get the database items
        const last_item = items.slice(-1)[0] // find the last item in the list
        

        data = await Window.db._remoteDbEncrypted.get(last_item._id) // get the record 
        console.log("Remote data", data);

        setRemoteData(data)
    }

    displayData = function(data) {
        if (data === "") {
            return (
                <div></div>
            )
        }
        return (
            <div>
                <textarea rows="7" cols="80" defaultValue={JSON.stringify(data)}>
                    
                </textarea>
            </div>
        )
    }

    localDataDisplay = displayData(localData)
    remoteDataDisplay = displayData(remoteData)

    const isLoggedIn = (DID !== null);
    if (isLoggedIn) {
        return (
            <div>
                <button onClick={this.showLocal}>Show Local Data</button>
                {localDataDisplay}
                <button onClick={this.showRemote}>Show Remote Data</button>
                {remoteDataDisplay}
            </div>    
        )
    } else {
        return (
            <div className="admonition admonition-danger alert alert--danger">
                <h1>Please login <a href="#login">above</a></h1>
            </div>
        );
    }

}

```
